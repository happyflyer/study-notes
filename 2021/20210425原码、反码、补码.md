# 原码、反码、补码

- [原码, 反码, 补码 详解](https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/computercode.html)

## 1. 机器数和真值

### 1.1. 机器数

- 一个数在计算机中的二进制表示形式，叫做这个数的机器数
- 机器数是带符号的，在计算机用一个数的最高位存放符号，正数为 $0$，负数为 $1$

举例：

- $+3$ 的**机器数**为 $0000 \ 0011$
- $-3$ 的**机器数**为 $1000 \ 0011$

### 1.2. 真值

- 因为第一位是符号位，所以机器数的形式值就不等于真正的数值
- 将带符号位的机器数对应的真正数值称为机器数的真值

举例：

- $0000 \ 0011$ 的**真值**为 $3$，**形式值**为 $3$
- $1000 \ 0011$ 的**真值**为 $-3$，**形式值**为 $131$

## 2. 概念和计算方法

### 2.1. 原码

- 原码就是符号位加上真值的绝对值，即：**用第一位表示符号，其余位表示值**
- 原码是人脑最容易理解和计算的表示方式

举例：

$$
\begin{aligned}
+127&=[0111 \ 1111]_原\\
+1&=[0000 \ 0001]_原\\
+0&=[0000 \ 0000]_原\\
-0&=[1000 \ 0000]_原\\
-1&=[1000 \ 0001]_原\\
-127&=[1111 \ 1111]_原
\end{aligned}
$$

因为第一位是符号位，所以取值范围：

$$
\begin{aligned}
\\
[1111 \ 1111&,0111 \ 1111]\\
[-(2^7-1)&,2^7-1]\\
[-127&,127]
\end{aligned}
$$

$0$ 有两种原码表示。

### 2.2. 反码

- 正数的反码是其本身
- 负数的反码是在其原码的基础上，**符号位不变，其余各个位取反**
- 如果一个反码表示的是负数，人脑无法直观的看出来它的数值。通常要将其转换成原码再计算

举例：

$$
\begin{aligned}
+127&=[0111 \ 1111]_原&=[0111 \ 1111]_反\\
+1&=[0000 \ 0001]_原&=[0000 \ 0001]_反\\
+0&=[0000 \ 0000]_原&=[0000 \ 0000]_反\\
-0&=[1000 \ 0000]_原&=[1111 \ 1111]_反\\
-1&=[1000 \ 0001]_原&=[1111 \ 1110]_反\\
-127&=[1111 \ 1111]_原&=[1000 \ 0000]_反
\end{aligned}
$$

同样地，$0$ 有两种编码。

> 不考虑符号的话，实际上，-0 变成了 127，-1 变成了 126，-127 变成了 0。

### 2.3. 补码

- 正数的补码就是其本身
- 负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后 $+1$。（即：**在反码的基础上$+1$**）
- 对于负数，补码表示方式也是人脑无法直观看出其数值的，通常也需要转换成原码在计算其数值

举例：

$$
\begin{aligned}
+127&=[0111 \ 1111]_原&=[0111 \ 1111]_反&=[0111 \ 1111]_补\\
+1&=[0000 \ 0001]_原&=[0000 \ 0001]_反&=[0000 \ 0001]_补\\
0&=[0000 \ 0000]_原&=[0000 \ 0000]_反&=[0000 \ 0000]_补\\
-1&=[1000 \ 0001]_原&=[1111 \ 1110]_反&=[1111 \ 1111]_补\\
-127&=[1111 \ 1111]_原&=[1000 \ 0000]_反&=[1000 \ 0001]_补\\
-128&&&=[1000 \ 0000]_补
\end{aligned}
$$

> 原来的 -0 的反码（$[1111 \ 1111]_反$）+1 之后，变成了 $[1000 \ 0000]_补$，这个补码不再给 -0 使用，而是分配给 -128。

## 3. 为何要使用原码、反码、补码

### 3.1. 原码不行

- 人脑可以知道第一位是符号位，但让计算机辨别“符号位”会使基础电路设计变得十分复杂
- 可以设计成将**符号位也参与运算**
- 减法可以转换成加法，机器可以设计成**只有加法**而没有减法

$$
\begin{aligned}
1-1
&=1+(-1)\\
&=[0000 \ 0001]_原 + [1000 \ 0001]_原\\
&=[1000 \ 0010]_原\\
&=-2
\end{aligned}
$$

- 如果用原码表示，让符号位也参与计算，显然对于减法来说，结果是不正确的
- 这也就是为何计算机内部不使用原码表示一个数

### 3.2. 反码有问题

$$
\begin{aligned}
1-1
&=1+(-1)\\
&=[0000 \ 0001]_原 + [1000 \ 0001]_原\\
&=[0000 \ 0001]_反 + [1111 \ 1110]_反\\
&=[1111 \ 1111]_反\\
&=[1000 \ 0000]_原\\
&=-0
\end{aligned}
$$

- 用反码计算减法，结果的真值部分是正确的
- 唯一的问题其实就出现在 $0$ 这个特殊的数值上
- 虽然人们理解上 $+0$ 和 $-0$ 是一样的，但是 $0$ 带符号是没有任何意义的
- 而且会有 $[0000 \ 0000]_原$ 和 $[1000 \ 0000]_原$ 两个编码表示 $0$

### 3.3. 引入补码

- 补码的出现，解决了 $0$ 的符号以及两个编码的问题

$$
\begin{aligned}
1-1
&=1+(-1)\\
&=[0000 \ 0001]_原 + [1000 \ 0001]_原\\
&=[0000 \ 0001]_补 + [1111 \ 1111]_补\\
&=[0000 \ 0000]_补\\
&=[0000 \ 0000]_原\\
&=0
\end{aligned}
$$

- $0$ 用 $[0000 \ 0000]$ 表示
- 而以前出现问题的 $-0$ 则不存在了
- 而且可以用 $[1000 \ 0000]$ 表示 $-128$

$$
\begin{aligned}
(-1)+(-127)
&=[1000 \ 0001]_原 + [1111 \ 1111]_原\\
&=[1111 \ 1111]_补 + [1000 \ 0001]_补\\
&=[1000 \ 0000]_补
\end{aligned}
$$

- $-1-127$ 的结果应该是 $-128$
- 所以在补码运算中，定义 $[1000 \ 0000]_补$ 就是 $-128$
- 因为实际上是使用以前的 $-0$ 的补码来表示 $-128$，所以 $-128$ 并**没有原码和反码**表示

### 3.4. 总结

- 原码或反码表示的范围为 $[-127,+127]$
- 补码表示的范围为 $[-128,127]$

因为机器使用补码，所以对于编程中常用到的 $32$ 位 int 类型，可以表示范围是:

$$
\begin{aligned}
\\
[-2^{31}&,2^{31}-1]\\
[-2147483648&,2147483647]
\end{aligned}
$$

因为第一位表示的是符号位，而使用补码表示时又可以多保存一个最小值。

## 4. 再深入

### 4.1. 模运算和同余

- 两个整数 `a`，`b`，若它们除以整数 `m` 所得的余数相等，则称 `a`，`b` 对于模 `m` 同余。

记作：

$$
a \equiv b \pmod{m}
$$

读作 `a` 与 `b` 关于模 `m` 同余。

举例：$4$，$16$，$28$ 关于模 $12$ 同余。

$$
\begin{aligned}
4 \bmod 12 &= 4\\
16 \bmod 12 &= 4\\
28 \bmod 12 &= 4
\end{aligned}
$$

### 4.2. 负数取模

$$
x \bmod y = x - y \lfloor x / y \rfloor
$$

$x \bmod y$ 等于 $x$ 减去 $y$ 乘上 $x$ 与 $y$ 的商的下界。

以 $-3 \bmod 2$ 举例：

$$
\begin{aligned}
-3 \bmod 2
&=-3 - 2 \times \lfloor -3/2 \rfloor\\
&=-3 - 2 \times \lfloor -1.5 \rfloor\\
&=-3 - 2 \times (-2)\\
&=-3 + 4\\
&=1
\end{aligned}
$$

$$
\begin{aligned}
(-2) \bmod 12 &= 12 - 2 &= 10\\
(-4) \bmod 12 &= 12 - 4 &= 8\\
(-5) \bmod 12 &= 12 - 5 &= 7
\end{aligned}
$$

对于时钟回拨问题：

- 回拨 2 小时=前拨 10 小时
- 回拨 4 小时=前拨 8 小时
- 回拨 5 小时=前拨 7 小时

### 4.3. 同余数的两个定理

#### 4.3.1. 反身性

$$
a \equiv a \pmod{m}
$$

#### 4.3.2. 线性运算定理

如果，

$$
\begin{aligned}
a & \equiv b \pmod{m}\\
c & \equiv d \pmod{m}
\end{aligned}
$$

那么：

$$
\begin{aligned}
a \pm c & \equiv b \pm d \pmod{m}\\
a * c & \equiv b * d \pmod{m}
\end{aligned}
$$

举例：

$$
\begin{aligned}
7 & \equiv 7 \pmod{12}\\
(-2) & \equiv 10 \pmod{12}\\
(7 - 2) & \equiv (7 + 10) \pmod{12}
\end{aligned}
$$

### 4.4. 反码为什么可以算对真值

看一下：$2-1=1$ 的问题

$$
\begin{aligned}
2 - 1
&=2 + (-1)\\
&=[0000 \ 0010]_原 + [1000 \ 0001]_原\\
&=[0000 \ 0010]_反 + [1111 \ 1110]_反\\
2 + 126
&=[0000 \ 0010]_原 + [0111 \ 1110]_原
\end{aligned}
$$

- $-1$ 的反码表示是 $[1111 \ 1110]$
- 如果这里将 $[1111 \ 1110]$ 认为是原码，则 $[1111 \ 1110]_原=-126$
- 这里将符号位除去，即认为是 $126$

可以知道，

$$
\begin{aligned}
(-1) \bmod 127 &= 126\\
126 \bmod 127 &= 126
\end{aligned}
$$

所以，

$$
\begin{aligned}
(-1) & \equiv 126 \pmod{127}\\
(2-1) & \equiv (2+126) \pmod{127}
\end{aligned}
$$

所以，

- $2-1$ 与 $2+126$ 的余数结果是相同的
- 而这个余数，正是我们的期望的计算结果
- 所以说：**一个数的反码,实际上是这个数对于一个模的同余数**
- 这个模并不是我们的二进制,而是**所能表示的最大值**
- 就像钟表一样，转了一圈后，总能找到在可表示范围内的一个正确的数值
- 而 $2+126$ 相当于钟表转过了一轮，而因为符号位是参与计算的，正好和溢出的最高位形成正确的运算结果

### 4.5. 补码为什么可以算对

$$
\begin{aligned}
2 - 1
&=2 + (-1)\\
&=[0000 \ 0010]_原 + [1000 \ 0001]_原\\
&=[0000 \ 0010]_反 + [1111 \ 1110]_反\\
&=[0000 \ 0010]_补 + [1111 \ 1111]_补\\
2 + 127
&=[0000 \ 0010]_原 + [0111 \ 1111]_原
\end{aligned}
$$

- 如果把 $[1111 \ 1111]$ 当成原码，去除符号位
- 则 $[1111 \ 1111]_原=-127$
- 这里将符号位除去，即认为是 $127$

其实,在反码的基础上+1,只是相当于增加了模的值

$$
(-1) \bmod 128 = 127\\
127 \bmod 128 = 127\\
(2-1) \equiv (2+127) \pmod{128}\\
$$

## 5. 总结

区间映射关系：

$$
\begin{aligned}
\\
[0,127] & \rightarrow [0,127]\\
[128,255] & \rightarrow [-128,-1]
\end{aligned}
$$

负数区间的映射过程：

$$
[+0,+127] \rightarrow [-127,-0] \rightarrow [-128,-1]
$$
